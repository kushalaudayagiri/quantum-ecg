{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bfc6c7f0-81e0-43e3-a76c-ba969591d17f",
   "metadata": {},
   "outputs": [],
   "source": [
    "!pip install qiskit qiskit-machine-learning scikit-learn pandas numpy matplotlib seaborn\n",
    "!pip install --upgrade qiskit-aer\n",
    "\n",
    "# IMPORTS\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.preprocessing import StandardScaler, LabelEncoder\n",
    "from sklearn.svm import SVC\n",
    "from sklearn.decomposition import PCA\n",
    "from sklearn.metrics import accuracy_score, confusion_matrix\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "from qiskit.circuit.library import PauliFeatureMap, ZZFeatureMap\n",
    "from qiskit_machine_learning.algorithms import QSVC\n",
    "from qiskit_machine_learning.kernels import QuantumKernel\n",
    "from qiskit.utils import algorithm_globals\n",
    "from qiskit_aer import AerSimulator\n",
    "\n",
    "algorithm_globals.random_seed = 42\n",
    "np.random.seed(42)\n",
    "\n",
    "print(\"QSVM vs Classical SVM for ECG Classification\")\n",
    "\n",
    "class ECGDataGenerator:\n",
    "    def __init__(self, random_state=42):\n",
    "        np.random.seed(random_state)\n",
    "        self.feature_names = ['Ventricular_Rate','Atrial_Rate','QRS_Duration','Q_Interval',\n",
    "                              'QT_Corrected','R_Axis','T_Axis','QRS_Count',\n",
    "                              'Q_Onset','Q_Offset','T_Offset']\n",
    "        self.classes = ['AFIB','GSVT','SB','SR']\n",
    "        self.class_desc = {'AFIB':'Atrial Fibrillation','GSVT':'Supraventricular Tachycardia',\n",
    "                           'SB':'Sinus Bradycardia','SR':'Sinus Rhythm (Normal)'}\n",
    "    \n",
    "    def generate_class_features(self, class_name, n_samples):\n",
    "        if class_name==\"AFIB\":\n",
    "            params = [(110,20),(150,30),(100,15),(120,20),(420,40),(60,30),(40,25),(90,10),(50,10),(350,30),(400,40)]\n",
    "        elif class_name==\"GSVT\":\n",
    "            params = [(160,25),(160,25),(90,12),(100,15),(380,35),(75,25),(50,20),(110,15),(45,8),(320,25),(370,30)]\n",
    "        elif class_name==\"SB\":\n",
    "            params = [(45,8),(45,8),(95,10),(130,18),(440,35),(65,20),(35,15),(45,5),(55,12),(380,35),(430,40)]\n",
    "        else:\n",
    "            params = [(75,12),(75,12),(95,10),(120,15),(410,30),(70,20),(45,18),(75,8),(50,10),(350,25),(400,35)]\n",
    "        features = [[np.random.normal(m,s) for m,s in params] for _ in range(n_samples)]\n",
    "        return np.array(features)\n",
    "    \n",
    "    def generate_dataset(self, total_samples=2000):\n",
    "        class_props = {'AFIB':0.15,'GSVT':0.25,'SB':0.20,'SR':0.40}\n",
    "        features, labels = [], []\n",
    "        print(\"Generating ECG dataset...\")\n",
    "        for cls, prop in class_props.items():\n",
    "            n_samp = int(total_samples*prop)\n",
    "            fts = self.generate_class_features(cls,n_samp)\n",
    "            features.extend(fts)\n",
    "            labels.extend([cls]*n_samp)\n",
    "            print(f\"{cls} ({self.class_desc[cls]}): {n_samp} samples\")\n",
    "        return np.array(features), np.array(labels)\n",
    "\n",
    "class QuantumClassicalComparator:\n",
    "    def __init__(self):\n",
    "        self.label_encoder=LabelEncoder()\n",
    "        self.scaler=StandardScaler()\n",
    "        self.backend=AerSimulator()\n",
    "        self.results = {}\n",
    "        \n",
    "    def preprocess_data(self,X,y):\n",
    "        y_enc=self.label_encoder.fit_transform(y)\n",
    "        X_train,X_test,y_train,y_test=train_test_split(X,y_enc,test_size=0.2,random_state=42,stratify=y_enc)\n",
    "        X_train_scale=self.scaler.fit_transform(X_train)\n",
    "        X_test_scale=self.scaler.transform(X_test)\n",
    "        return X_train_scale,X_test_scale,y_train,y_test\n",
    "    \n",
    "    def train_classical_svm(self,X_train,X_test,y_train,y_test):\n",
    "        clf=SVC(kernel='rbf',random_state=42)\n",
    "        clf.fit(X_train,y_train)\n",
    "        y_pred=clf.predict(X_test)\n",
    "        acc=accuracy_score(y_test,y_pred)\n",
    "        return acc,y_pred\n",
    "    \n",
    "    def train_quantum_svm(self,X_train,X_test,y_train,y_test,feature_map_name):\n",
    "        n_feat=X_train.shape[1]\n",
    "        if feature_map_name=='PauliX':\n",
    "            fmap=PauliFeatureMap(feature_dimension=n_feat,reps=1,paulis=['X'])\n",
    "        elif feature_map_name=='PauliZ':\n",
    "            fmap=PauliFeatureMap(feature_dimension=n_feat,reps=1,paulis=['Z'])\n",
    "        else:\n",
    "            raise ValueError('Unsupported feature map.')\n",
    "        qkernel=QuantumKernel(feature_map=fmap,quantum_instance=self.backend)\n",
    "        qsvm=QSVC(quantum_kernel=qkernel)\n",
    "        subset_size = min(150, len(X_train))\n",
    "        idxs = np.random.choice(len(X_train),subset_size,replace=False)\n",
    "        X_train_sub, y_train_sub = X_train[idxs], y_train[idxs]\n",
    "        qsvm.fit(X_train_sub,y_train_sub)\n",
    "        y_pred=qsvm.predict(X_test)\n",
    "        acc=accuracy_score(y_test,y_pred)\n",
    "        return acc,y_pred\n",
    "    \n",
    "    def run_experiment(self,X,y):\n",
    "        X_train,X_test,y_train,y_test = self.preprocess_data(X,y)\n",
    "        qubits=[3,5]\n",
    "        feature_maps=['PauliX','PauliZ']\n",
    "\n",
    "        for n_qubits in qubits:\n",
    "            pca=PCA(n_components=n_qubits,random_state=42)\n",
    "            X_train_pca=pca.fit_transform(X_train)\n",
    "            X_test_pca=pca.transform(X_test)\n",
    "            classical_acc,classical_pred=self.train_classical_svm(X_train_pca,X_test_pca,y_train,y_test)\n",
    "            best_quantum_acc=0;best_map=None;best_quantum_pred=None\n",
    "            for fmap in feature_maps:\n",
    "                quantum_acc, quantum_pred = self.train_quantum_svm(X_train_pca, X_test_pca, y_train, y_test, fmap)\n",
    "                if quantum_acc>best_quantum_acc:\n",
    "                    best_quantum_acc=quantum_acc\n",
    "                    best_map=fmap\n",
    "                    best_quantum_pred=quantum_pred\n",
    "            print(f\"Qubits: {n_qubits} | Classical: {classical_acc:.4f} | Quantum: {best_quantum_acc:.4f} | Map: {best_map}\")\n",
    "            self.results[n_qubits]={'classical_accuracy': classical_acc,'quantum_accuracy': best_quantum_acc,\n",
    "                                   'best_feature_map': best_map,'classical_pred': classical_pred,'quantum_pred': best_quantum_pred,\n",
    "                                   'pca_variance': pca.explained_variance_ratio_.sum()}\n",
    "        self.y_test = y_test\n",
    "        return self.results\n",
    "\n",
    "def plot_results(results, y_test, classes):\n",
    "    sns.set(style='whitegrid')\n",
    "    qubits = list(results.keys())\n",
    "    classical_acc = [results[q]['classical_accuracy'] for q in qubits]\n",
    "    quantum_acc = [results[q]['quantum_accuracy'] for q in qubits]\n",
    "    gaps = [c - q for c, q in zip(classical_acc, quantum_acc)]\n",
    "    \n",
    "    plt.figure(figsize=(10,6))\n",
    "    width=0.35\n",
    "    x=np.arange(len(qubits))\n",
    "    plt.bar(x - width/2, classical_acc, width, label='Classical SVM', color='blue')\n",
    "    plt.bar(x + width/2, quantum_acc, width, label='Quantum SVM', color='red')\n",
    "    plt.xticks(x, [str(q) for q in qubits])\n",
    "    plt.xlabel('Number of Qubits')\n",
    "    plt.ylabel('Accuracy')\n",
    "    plt.title('QSVM vs Classical SVM')\n",
    "    plt.legend()\n",
    "    plt.show()\n",
    "    \n",
    "    plt.figure(figsize=(6,4))\n",
    "    plt.bar(qubits,gaps,color='orange')\n",
    "    plt.xlabel('Number of Qubits')\n",
    "    plt.ylabel('Performance Gap (Classical - Quantum)')\n",
    "    plt.title('Performance Gap')\n",
    "    plt.show()\n",
    "    \n",
    "    best_qubits = qubits[np.argmax(classical_acc)]\n",
    "    best_result = results[best_qubits]\n",
    "    cm_classical = confusion_matrix(y_test, best_result['classical_pred'])\n",
    "    cm_quantum = confusion_matrix(y_test, best_result['quantum_pred'])\n",
    "    \n",
    "    plt.figure(figsize=(14,6))\n",
    "    plt.subplot(1,2,1)\n",
    "    sns.heatmap(cm_classical, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\n",
    "    plt.title(f'Classical SVM Confusion Matrix ({best_qubits} Qubits)')\n",
    "    plt.xlabel('Predicted')\n",
    "    plt.ylabel('True')\n",
    "    \n",
    "    plt.subplot(1,2,2)\n",
    "    sns.heatmap(cm_quantum, annot=True, fmt='d', cmap='Reds', xticklabels=classes, yticklabels=classes)\n",
    "    plt.title(f'Quantum SVM Confusion Matrix ({best_qubits} Qubits)')\n",
    "    plt.xlabel('Predicted')\n",
    "    plt.ylabel('True')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n",
    "if __name__==\"__main__\":\n",
    "    ecg_gen = ECGDataGenerator()\n",
    "    X,y = ecg_gen.generate_dataset(2000)\n",
    "    comparator = QuantumClassicalComparator()\n",
    "    results = comparator.run_experiment(X,y)\n",
    "    plot_results(results, comparator.y_test, ecg_gen.classes)\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
